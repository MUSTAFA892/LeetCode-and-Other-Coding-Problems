# ğŸ§¾ Explanation of the Code

### Goal

We want to assign meetings to rooms under these rules:

1. If any rooms are free â†’ pick the **smallest-numbered** one
2. If none are free â†’ **delay** the meeting until some room is free
3. A delayed meeting keeps its **original duration**
4. Track how many meetings each room hosts
5. Return the room with the **most meetings** (smallest index if tie)

---

## ğŸ§  Data Structures Used

### âœ” `available` (min-heap of room IDs)

Holds IDs of rooms that are free
Always gives the **smallest room number first**

---

### âœ” `busy_rooms` (min-heap of `(endTime, roomId)`)

Tracks currently occupied rooms

* sorted by **earliest end time**
* top element = room that becomes free first

---

### âœ” `counts`

`counts[i] = number of meetings hosted by room i`

---

## ğŸ“ Algorithm Flow

### 1ï¸âƒ£ Sort meetings by start time

```python
meetings.sort()
```

---

### 2ï¸âƒ£ Process meetings one-by-one

```python
for each meeting:
```

Let:

```
start = meetings[i][0]
end   = meetings[i][1]
duration = end - start
```

---

### 3ï¸âƒ£ Before assigning, free rooms that have finished

```python
while busy_rooms and busy_rooms[0][0] <= start:
```

If a roomâ€™s endTime â‰¤ current meeting start:

* pop it from busy_rooms
* push its roomId back into available

This simulates rooms becoming free **at the correct times**.

---

### 4ï¸âƒ£ Case A â€” There is a free room

```python
if available:
    pop smallest roomId
    schedule normally (endTime = meeting end)
    increment count
```

---

### 5ï¸âƒ£ Case B â€” No free rooms â†’ Delay meeting

```python
else:
    pop earliest-finishing room
    new_endTime = earliest_end + duration
    push back with new_endTime
    increment that room's count
```

So the meeting **starts when the room frees**.

---

### 6ï¸âƒ£ After all meetings

Return the room with max count:

```python
return counts.index(max(counts))
```

Leetcode guarantee makes tie-breaking correct.

---

# ğŸ§ª Worked Example

Letâ€™s simulate:

```
n = 2
meetings = [[0,10],[1,5],[2,7],[3,4]]
```

Rooms: `0 and 1`

---

## INITIAL

```
available = [0,1]
busy_rooms = []
counts = [0,0]
```

---

## â­ Meeting 1 â†’ [0,10]

start = 0, end = 10, duration = 10

Free finished rooms? â†’ none

available not empty â†’ take room 0

```
busy_rooms push (10,0)
counts = [1,0]
available = [1]
```

---

## â­ Meeting 2 â†’ [1,5]

start = 1, end = 5, duration = 4

Free rooms?
earliest busy = 10 > 1 â†’ none

available has room 1 â†’ use it

```
busy_rooms push (5,1)
counts = [1,1]
available = []
busy_rooms = [(5,1),(10,0)]
```

(Heap sorted by endTime)

---

## â­ Meeting 3 â†’ [2,7]

start = 2, duration = 5

Free rooms?
(5,1) ends at 5 > 2 â†’ none
No available rooms â†’ delay

Pop earliest:

```
(5,1)
```

Delayed start = 5
So new end = 5 + 5 = 10

Push back:

```
busy_rooms = [(10,0),(10,1)]
counts = [1,2]
```

---

## â­ Meeting 4 â†’ [3,4]

start = 3, duration = 1

Free rooms?
earliest = 10 > 3 â†’ none

No available rooms â†’ delay again

Pop earliest â€” tie â†’ room 0 (smaller id)

```
(10,0)
```

Delayed start = 10
New end = 10 + 1 = 11

Push:

```
busy_rooms = [(10,1),(11,0)]
counts = [2,2]
```

---

# ğŸ Final Counts

```
Room 0 â†’ 2 meetings
Room 1 â†’ 2 meetings
```

Tie â†’ smallest index

### âœ… Output = 0
