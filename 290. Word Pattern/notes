## âœ… Problem Summary: Word Pattern

Given:

* A `pattern` string like `"abba"`
* A string `s` like `"dog cat cat dog"`

You need to check if the words in `s` follow the **same pattern** as the letters in `pattern`, where:

* Each character in `pattern` maps to **exactly one unique word** in `s`, and
* Each word in `s` maps to **exactly one unique character** in `pattern`

> ğŸ§  This is called a **bijective** mapping (one-to-one and onto).

---

## ğŸ” Let's Use Your Example:

```python
pattern = "abba"
s = "dog cat cat dog"
```

---

### ğŸ¯ Goal:

Check if:

* `'a' â†’ dog`
* `'b' â†’ cat`
* And second `'b'` maps to `cat`, second `'a'` maps to `dog`
* No word is reused for a different pattern letter (e.g., `'b'` can't map to both `"cat"` and `"dog"`)

Expected output: **`True`** âœ…

---

## ğŸ§ª Step-by-Step Walkthrough of Your Code

```python
s_map = {}         # Word-to-pattern mapping
pattern_map = {}   # Pattern-to-word mapping
s = s.split()      # ['dog', 'cat', 'cat', 'dog']
```

Now loop over each position `i` from 0 to 3:

---

### â¤ i = 0

* `pattern[0] = 'a'`
* `s[0] = 'dog'`

**Mappings:**

* `'a'` not in `pattern_map` â†’ add: `'a' â†’ 'dog'`
* `'dog'` not in `s_map`, and `'a' â†’ 'dog'` â†’ add: `'dog' â†’ 'a'`

âœ… Good so far.

---

### â¤ i = 1

* `pattern[1] = 'b'`
* `s[1] = 'cat'`

**Mappings:**

* `'b'` not in `pattern_map` â†’ add: `'b' â†’ 'cat'`
* `'cat'` not in `s_map`, and `'b' â†’ 'cat'` â†’ add: `'cat' â†’ 'b'`

âœ… Still good.

---

### â¤ i = 2

* `pattern[2] = 'b'`
* `s[2] = 'cat'`

**Mappings:**

* `'b'` already maps to `'cat'` â€” âœ… match
* `'cat'` already maps to `'b'` â€” âœ… match

No change needed â€” pass.

---

### â¤ i = 3

* `pattern[3] = 'a'`
* `s[3] = 'dog'`

**Mappings:**

* `'a'` â†’ `'dog'` â€” âœ…
* `'dog'` â†’ `'a'` â€” âœ…

Still matches â€” âœ…

---

### ğŸ¯ Final Return:

```python
return flag  # which is still True
```

âœ… Output: **True**, as expected.
