### Problem Recap

Given:

* `strs`: list of binary strings
* `m`: max number of 0â€™s allowed
* `n`: max number of 1â€™s allowed

ðŸ‘‰ Find the **largest subset** of `strs` such that total 0â€™s â‰¤ m and total 1â€™s â‰¤ n.

---

## ðŸ§© **Approach 1 â€” Optimized Dictionary-based Dynamic Programming (DP)**

### ðŸ”¹ Code

```python
dp = {(0, 0): 0}

for s in strs:
    zeros = s.count('0')
    ones = s.count('1')
    new = {}
    
    for (PrevZeros , PrevOnes), val in dp.items():
        NewZeros, NewOnes = PrevZeros + zeros, PrevOnes + ones
        
        if NewZeros <= m and NewOnes <= n:
            if (NewZeros, NewOnes) not in dp or dp[(NewZeros, NewOnes)] < val + 1:
                new[(NewZeros, NewOnes)] = val + 1
                
    dp.update(new)

print(max(dp.values()))
```

---

### ðŸ”¹ **Concept**

* Each entry in `dp` represents a possible combination of 0â€™s and 1â€™s used.
* `dp[(zeros, ones)] = subset_size` â†’
  means: we can build a subset of size `subset_size` using that many zeros and ones.
* For every new string, we **extend** all current combinations with it â€” if it fits within limits `(m, n)`.

---

### ðŸ”¹ **Working Example**

```
strs = ["10", "0001", "111001", "1", "0"]
m = 5, n = 3
```

| Step     | String | (Zeros, Ones)           | DP States Formed |
| -------- | ------ | ----------------------- | ---------------- |
| Start    | â€”      | â€”                       | {(0,0):0}        |
| "10"     | (1,1)  | {(1,1):1}               |                  |
| "0001"   | (3,1)  | {(4,2):2} (add to â€œ10â€) |                  |
| "111001" | (2,4)  | âŒ (too many 1â€™s)        |                  |
| "1"      | (0,1)  | {(1,2):2}, {(4,3):3}    |                  |
| "0"      | (1,0)  | {(2,2):3}, {(5,3):4} âœ…  |                  |

âœ… Final `max(dp.values()) = 4`

**Answer:** `4`

---

### ðŸ”¹ **Advantages**

âœ… Very efficient â€” runs fast even for large input
âœ… Avoids recomputation automatically
âœ… No nested 2D loops
âœ… Memory efficient (stores only valid states)

### ðŸ”¹ **Time Complexity**

O(len(strs) Ã— m Ã— n)

### ðŸ”¹ **Output for Test**

```
Input: ["10","0001","111001","1","0"], m=5, n=3
Output: 4 âœ…
```

---

## ðŸ§© **Approach 2 â€” Pure Brute Force Using Combinations**

### ðŸ”¹ Code

```python
import itertools

max_size = 0
for r in range(1, len(strs) + 1):             
    for subset in itertools.combinations(strs, r): 
        zeros = sum(s.count('0') for s in subset)
        ones = sum(s.count('1') for s in subset)

        if zeros <= m and ones <= n:
            max_size = max(max_size, len(subset))

print(max_size)
```

---

### ðŸ”¹ **Concept**

* Try **every possible subset** of `strs`.
* For each subset:

  * Count total zeros and ones.
  * Check if it fits within `(m, n)`.
  * Track the largest valid subset size.

---

### ðŸ”¹ **Working Example**

```
strs = ["10", "0", "1"]
m = 1, n = 1
```

| Subset         | (Zeros, Ones) | Valid? |
| :------------- | :-----------: | :----: |
| {"10"}         |     (1,1)     |    âœ…   |
| {"0"}          |     (1,0)     |    âœ…   |
| {"1"}          |     (0,1)     |    âœ…   |
| {"0","1"}      |     (1,1)     |    âœ…   |
| {"10","0"}     |     (2,1)     |    âŒ   |
| {"10","1"}     |     (1,2)     |    âŒ   |
| {"10","0","1"} |     (2,2)     |    âŒ   |

âœ… Largest valid subset = {"0", "1"}
âœ… Output: 2

---

### ðŸ”¹ **Advantages**

âœ… Easy to understand
âœ… Straightforward logic

### ðŸ”¹ **Disadvantages**

âŒ Extremely slow â€” checks all (2^n) subsets
âŒ Fails for large input (Time Limit Exceeded)
âŒ Repeats unnecessary calculations

### ðŸ”¹ **Time Complexity**

O(2^n Ã— len(strs)) â†’ exponential

### ðŸ”¹ **Output for Test**

```
Input: ["10","0001","111001","1","0"], m=5, n=3
Output: âŒ (TLE or very slow)
```
