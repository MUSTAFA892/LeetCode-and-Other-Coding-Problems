## ğŸ”¹ Step 1 â€” Understanding the task

* **Input:** `rowIndex` (0-based).
* **Output:** The row of Pascalâ€™s Triangle at index `rowIndex`.

**Example:**

```
rowIndex = 3
Pascal's Triangle rows:
0: [1]
1: [1,1]
2: [1,2,1]
3: [1,3,3,1]   â† this row is returned
```

---

## ğŸ”¹ Step 2 â€” Outer loop

```python
for i in range(rowIndex + 1):
```

* Builds **rows 0 â†’ rowIndex**.
* `i` = current row number.
* `range(rowIndex + 1)` ensures we **include the target row**.

---

## ğŸ”¹ Step 3 â€” Create row with 1â€™s

```python
temp_arr = [1] * (i+1)
```

* Row `i` has `i+1` elements.
* Initially, all elements are `1`.
* Example:

  * `i=0` â†’ `[1]`
  * `i=1` â†’ `[1,1]`
  * `i=2` â†’ `[1,1,1]` (middle element will be calculated)

---

## ğŸ”¹ Step 4 â€” Fill inner elements

```python
for j in range(1, i):
    temp_arr[j] = arr[i-1][j-1] + arr[i-1][j]
```

* **Inner elements** are calculated using the previous row:

  ```
  current_row[j] = previous_row[j-1] + previous_row[j]
  ```
* `range(1,i)` ensures we skip the **first and last elements**, which are always `1`.

---

## ğŸ”¹ Step 5 â€” Append row

```python
arr.append(temp_arr)
```

* We add the row to `arr` so it can be used to compute the next row.
* `arr[-1]` at the end will be the **last row**, which is our target.

---

## ğŸ”¹ Step 6 â€” Return the row

```python
return arr[-1]
```

* Returns only the **requested row**, not the whole triangle.

---

## ğŸ”¹ Step 7 â€” Walkthrough example: `rowIndex = 4`

We want **row 4** of Pascalâ€™s Triangle.

---

### Iteration 0 (`i = 0`)

* `temp_arr = [1]`
* Inner loop: none (`range(1,0)`)
* Append â†’ `arr = [[1]]`

---

### Iteration 1 (`i = 1`)

* `temp_arr = [1,1]`
* Inner loop: none (`range(1,1)`)
* Append â†’ `arr = [[1],[1,1]]`

---

### Iteration 2 (`i = 2`)

* `temp_arr = [1,1,1]`
* Inner loop: `range(1,2)` â†’ `j=1`

  ```
  temp_arr[1] = arr[1][0] + arr[1][1] = 1 + 1 = 2
  ```
* Append â†’ `arr = [[1],[1,1],[1,2,1]]`

---

### Iteration 3 (`i = 3`)

* `temp_arr = [1,1,1,1]`
* Inner loop: `range(1,3)` â†’ `j=1,2`

  ```
  j=1: temp_arr[1] = arr[2][0] + arr[2][1] = 1 + 2 = 3
  j=2: temp_arr[2] = arr[2][1] + arr[2][2] = 2 + 1 = 3
  ```
* Append â†’ `arr = [[1],[1,1],[1,2,1],[1,3,3,1]]`

---

### Iteration 4 (`i = 4`)

* `temp_arr = [1,1,1,1,1]`
* Inner loop: `range(1,4)` â†’ `j=1,2,3`

  ```
  j=1: temp_arr[1] = arr[3][0] + arr[3][1] = 1 + 3 = 4
  j=2: temp_arr[2] = arr[3][1] + arr[3][2] = 3 + 3 = 6
  j=3: temp_arr[3] = arr[3][2] + arr[3][3] = 3 + 1 = 4
  ```
* Append â†’ `arr = [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]`

---

### Return value:

```python
arr[-1] = [1,4,6,4,1]
```

âœ… Correct! This is **row 4** of Pascalâ€™s Triangle.

---

## ğŸ”¹ Step 8 â€” Key Points

1. **First & last elements = 1** â†’ handled by `[1]*(i+1)`.
2. **Inner elements = sum of two elements above** â†’ `arr[i-1][j-1] + arr[i-1][j]`.
3. **Loop ranges carefully**:

   * Outer: `i = 0 â†’ rowIndex`
   * Inner: `j = 1 â†’ i-1`
4. Append each row to `arr` so the **next row can access previous row**.
5. Return only the **last row** â†’ efficient for `getRow`.


