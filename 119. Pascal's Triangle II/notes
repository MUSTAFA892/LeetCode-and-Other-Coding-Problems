## 🔹 Step 1 — Understanding the task

* **Input:** `rowIndex` (0-based).
* **Output:** The row of Pascal’s Triangle at index `rowIndex`.

**Example:**

```
rowIndex = 3
Pascal's Triangle rows:
0: [1]
1: [1,1]
2: [1,2,1]
3: [1,3,3,1]   ← this row is returned
```

---

## 🔹 Step 2 — Outer loop

```python
for i in range(rowIndex + 1):
```

* Builds **rows 0 → rowIndex**.
* `i` = current row number.
* `range(rowIndex + 1)` ensures we **include the target row**.

---

## 🔹 Step 3 — Create row with 1’s

```python
temp_arr = [1] * (i+1)
```

* Row `i` has `i+1` elements.
* Initially, all elements are `1`.
* Example:

  * `i=0` → `[1]`
  * `i=1` → `[1,1]`
  * `i=2` → `[1,1,1]` (middle element will be calculated)

---

## 🔹 Step 4 — Fill inner elements

```python
for j in range(1, i):
    temp_arr[j] = arr[i-1][j-1] + arr[i-1][j]
```

* **Inner elements** are calculated using the previous row:

  ```
  current_row[j] = previous_row[j-1] + previous_row[j]
  ```
* `range(1,i)` ensures we skip the **first and last elements**, which are always `1`.

---

## 🔹 Step 5 — Append row

```python
arr.append(temp_arr)
```

* We add the row to `arr` so it can be used to compute the next row.
* `arr[-1]` at the end will be the **last row**, which is our target.

---

## 🔹 Step 6 — Return the row

```python
return arr[-1]
```

* Returns only the **requested row**, not the whole triangle.

---

## 🔹 Step 7 — Walkthrough example: `rowIndex = 4`

We want **row 4** of Pascal’s Triangle.

---

### Iteration 0 (`i = 0`)

* `temp_arr = [1]`
* Inner loop: none (`range(1,0)`)
* Append → `arr = [[1]]`

---

### Iteration 1 (`i = 1`)

* `temp_arr = [1,1]`
* Inner loop: none (`range(1,1)`)
* Append → `arr = [[1],[1,1]]`

---

### Iteration 2 (`i = 2`)

* `temp_arr = [1,1,1]`
* Inner loop: `range(1,2)` → `j=1`

  ```
  temp_arr[1] = arr[1][0] + arr[1][1] = 1 + 1 = 2
  ```
* Append → `arr = [[1],[1,1],[1,2,1]]`

---

### Iteration 3 (`i = 3`)

* `temp_arr = [1,1,1,1]`
* Inner loop: `range(1,3)` → `j=1,2`

  ```
  j=1: temp_arr[1] = arr[2][0] + arr[2][1] = 1 + 2 = 3
  j=2: temp_arr[2] = arr[2][1] + arr[2][2] = 2 + 1 = 3
  ```
* Append → `arr = [[1],[1,1],[1,2,1],[1,3,3,1]]`

---

### Iteration 4 (`i = 4`)

* `temp_arr = [1,1,1,1,1]`
* Inner loop: `range(1,4)` → `j=1,2,3`

  ```
  j=1: temp_arr[1] = arr[3][0] + arr[3][1] = 1 + 3 = 4
  j=2: temp_arr[2] = arr[3][1] + arr[3][2] = 3 + 3 = 6
  j=3: temp_arr[3] = arr[3][2] + arr[3][3] = 3 + 1 = 4
  ```
* Append → `arr = [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]`

---

### Return value:

```python
arr[-1] = [1,4,6,4,1]
```

✅ Correct! This is **row 4** of Pascal’s Triangle.

---

## 🔹 Step 8 — Key Points

1. **First & last elements = 1** → handled by `[1]*(i+1)`.
2. **Inner elements = sum of two elements above** → `arr[i-1][j-1] + arr[i-1][j]`.
3. **Loop ranges carefully**:

   * Outer: `i = 0 → rowIndex`
   * Inner: `j = 1 → i-1`
4. Append each row to `arr` so the **next row can access previous row**.
5. Return only the **last row** → efficient for `getRow`.


