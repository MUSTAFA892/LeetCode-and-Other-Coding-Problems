# **Find the K-or of an Array**

## **Problem**
The K-or is calculated by checking each bit position across all numbers. If at least `k` numbers have a '1' at that position, the result has '1' at that position.

---

## **Test Case: nums = [7, 12, 9, 8, 9, 15], k = 4**

---

## **STEP 1: Convert to Binary Strings**

```python
final_bit = [bin(i)[2:] for i in nums]

Processing each number:
7  → bin(7)  = '0b111'  → '111'
12 → bin(12) = '0b1100' → '1100'
9  → bin(9)  = '0b1001' → '1001'
8  → bin(8)  = '0b1000' → '1000'
9  → bin(9)  = '0b1001' → '1001'
15 → bin(15) = '0b1111' → '1111'

final_bit = ['111', '1100', '1001', '1000', '1001', '1111']
```

---

## **STEP 2: Find Maximum Length**

```python
max_len = max(len(b) for b in final_bit)

Lengths: 3, 4, 4, 4, 4, 4
max_len = 4
```

---

## **STEP 3: Pad with Leading Zeros**

```python
final_bit = [b.zfill(max_len) for b in final_bit]

'111'.zfill(4)  = '0111'
'1100'.zfill(4) = '1100'
'1001'.zfill(4) = '1001'
'1000'.zfill(4) = '1000'
'1001'.zfill(4) = '1001'
'1111'.zfill(4) = '1111'

final_bit = ['0111', '1100', '1001', '1000', '1001', '1111']

Visual representation:
Position:  0    1    2    3
          ───  ───  ───  ───
Number 1:  0    1    1    1   (7)
Number 2:  1    1    0    0   (12)
Number 3:  1    0    0    1   (9)
Number 4:  1    0    0    0   (8)
Number 5:  1    0    0    1   (9)
Number 6:  1    1    1    1   (15)
```

---

## **STEP 4: Count 1's at Each Bit Position**

```python
bit_sum = [0] * max_len
bit_sum = [0, 0, 0, 0]

Loop through each binary string:
```

### **Process '0111' (number 7)**
```
Index 0: bit='0' → bit_sum[0] += 0 → bit_sum = [0, 0, 0, 0]
Index 1: bit='1' → bit_sum[1] += 1 → bit_sum = [0, 1, 0, 0]
Index 2: bit='1' → bit_sum[2] += 1 → bit_sum = [0, 1, 1, 0]
Index 3: bit='1' → bit_sum[3] += 1 → bit_sum = [0, 1, 1, 1]
```

### **Process '1100' (number 12)**
```
Index 0: bit='1' → bit_sum[0] += 1 → bit_sum = [1, 1, 1, 1]
Index 1: bit='1' → bit_sum[1] += 1 → bit_sum = [1, 2, 1, 1]
Index 2: bit='0' → bit_sum[2] += 0 → bit_sum = [1, 2, 1, 1]
Index 3: bit='0' → bit_sum[3] += 0 → bit_sum = [1, 2, 1, 1]
```

### **Process '1001' (number 9)**
```
Index 0: bit='1' → bit_sum[0] += 1 → bit_sum = [2, 2, 1, 1]
Index 1: bit='0' → bit_sum[1] += 0 → bit_sum = [2, 2, 1, 1]
Index 2: bit='0' → bit_sum[2] += 0 → bit_sum = [2, 2, 1, 1]
Index 3: bit='1' → bit_sum[3] += 1 → bit_sum = [2, 2, 1, 2]
```

### **Process '1000' (number 8)**
```
Index 0: bit='1' → bit_sum[0] += 1 → bit_sum = [3, 2, 1, 2]
Index 1: bit='0' → bit_sum[1] += 0 → bit_sum = [3, 2, 1, 2]
Index 2: bit='0' → bit_sum[2] += 0 → bit_sum = [3, 2, 1, 2]
Index 3: bit='0' → bit_sum[3] += 0 → bit_sum = [3, 2, 1, 2]
```

### **Process '1001' (number 9 again)**
```
Index 0: bit='1' → bit_sum[0] += 1 → bit_sum = [4, 2, 1, 2]
Index 1: bit='0' → bit_sum[1] += 0 → bit_sum = [4, 2, 1, 2]
Index 2: bit='0' → bit_sum[2] += 0 → bit_sum = [4, 2, 1, 2]
Index 3: bit='1' → bit_sum[3] += 1 → bit_sum = [4, 2, 1, 3]
```

### **Process '1111' (number 15)**
```
Index 0: bit='1' → bit_sum[0] += 1 → bit_sum = [5, 2, 1, 3]
Index 1: bit='1' → bit_sum[1] += 1 → bit_sum = [5, 3, 1, 3]
Index 2: bit='1' → bit_sum[2] += 1 → bit_sum = [5, 3, 2, 3]
Index 3: bit='1' → bit_sum[3] += 1 → bit_sum = [5, 3, 2, 4]
```

### **Final bit_sum**
```
bit_sum = [5, 3, 2, 4]

Meaning:
Position 0: 5 numbers have '1' at this position
Position 1: 3 numbers have '1' at this position
Position 2: 2 numbers have '1' at this position
Position 3: 4 numbers have '1' at this position
```

---

## **STEP 5: Build Result Based on k**

```python
k = 4
ans = []

Check each count in bit_sum:
```

### **Position 0: count = 5**
```
Is 5 >= 4? YES ✓
ans.append('1')
ans = ['1']
```

### **Position 1: count = 3**
```
Is 3 >= 4? NO ✗
ans.append('0')
ans = ['1', '0']
```

### **Position 2: count = 2**
```
Is 2 >= 4? NO ✗
ans.append('0')
ans = ['1', '0', '0']
```

### **Position 3: count = 4**
```
Is 4 >= 4? YES ✓
ans.append('1')
ans = ['1', '0', '0', '1']
```

---

## **STEP 6: Convert Binary String to Integer**

```python
ans = ['1', '0', '0', '1']
binary_string = ''.join(ans) = '1001'

Convert to decimal:
int('1001', 2) = 1×2³ + 0×2² + 0×2¹ + 1×2⁰
               = 8 + 0 + 0 + 1
               = 9

Return: 9 ✓
```

---

## **Visual Summary**

```
Original numbers:
7  = 0111
12 = 1100
9  = 1001
8  = 1000
9  = 1001
15 = 1111

Bit position:  0    1    2    3
Count of 1's:  5    3    2    4
k = 4:        >=4  <4   <4   >=4
Result bit:    1    0    0    1

Result: 1001 (binary) = 9 (decimal)
```
