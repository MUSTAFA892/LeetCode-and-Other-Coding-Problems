

1. **Understanding the Problem:**
   - You are given a 2D matrix (`heightMap`) where each value represents the height of a cell. The goal is to calculate how much water can be trapped between the cells after raining.

2. **Key Observations:**
   - Water will accumulate in valleys or depressions surrounded by higher cells.
   - The border cells can't trap any water because they act as the boundary.
   - The trapped water depends on the minimum height boundary surrounding the valley.

3. **Priority Queue (Min-Heap):**
   - A min-heap (priority queue) is used to process cells from the lowest boundary height to the highest. This helps in simulating how water can accumulate from the lowest boundary outwards.

4. **Start with Border Cells:**
   - The outermost cells are the boundary and serve as the boundary for water trapping. We initialize the min-heap with these border cells and mark them as visited by setting their values to `-1`.

5. **Process from the Border Inwards:**
   - By processing the lowest boundary cell first (because of the min-heap), we can ensure that we are considering the minimum height available to trap water.

6. **Max Height Tracking:**
   - As we process the cells, we keep track of the highest cell we've encountered (`max_h`). The difference between `max_h` and the current cell height gives us the amount of trapped water.

7. **Neighbor Exploration:**
   - For each cell, we look at its neighbors (up, down, left, right). If a neighbor hasnâ€™t been visited, we add it to the heap for future processing.

8. **Boundary Conditions:**
   - We ensure that we don't go out of bounds when exploring neighbors and that we only process unvisited cells.

9. **Accumulate Trapped Water:**
   - For each processed cell, we calculate the potential water trapped above it, using the formula: `max_h - current_height`, where `max_h` is the maximum height encountered so far.

10. **Return Result:**
   - The total amount of trapped water is accumulated in a result variable (`res`) and returned at the end.
---

We want to calculate **how much water can be trapped** inside a 2D elevation map (matrix).
Think of it like a **container made of blocks** â€” water can only be trapped if itâ€™s surrounded by taller walls.

Algorithm used here:

* BFS with **min-heap (priority queue)**.
* Always process the **lowest boundary** first.
* Keep track of the **highest wall seen so far**.
* Water trapped at a cell = `max_h - current_height`.

---

# ðŸ“Œ Example Input

```python
heightMap = [
  [1, 4, 3, 1, 3, 2],
  [3, 2, 1, 3, 2, 4],
  [2, 3, 3, 2, 3, 1]
]
```

Rows = 3
Cols = 6

---

# ðŸ›  Step 1 â€“ Put Boundary into MinHeap

We push all **border cells** into a min-heap.
Also, mark them as visited (`-1`).

Heap after inserting boundaries (value, row, col):

```
[(1,0,0), (4,0,1), (3,0,2), (1,0,3), (3,0,4), (2,0,5),
 (3,1,0), (4,1,5),
 (2,2,0), (3,2,1), (3,2,2), (2,2,3), (3,2,4), (1,2,5)]
```

`max_h = -1` initially.

---

# ðŸ›  Step 2 â€“ Pop from Heap (Process Cells)

We always pop the **lowest wall** first.
Keep track of `max_h = max(max_h, h)`.
Water trapped at this cell = `max_h - h`.
Then push unvisited neighbors into heap.

---

## ðŸ”¹ Iteration 1

Pop `(1,0,0)` â†’ lowest wall = 1
`max_h = max(-1,1) = 1`
Water trapped = `1-1 = 0`

Neighbors â†’ (1,1,0) already boundary, skip.

---

## ðŸ”¹ Iteration 2

Pop `(1,0,3)`
`max_h = max(1,1) = 1`
Water trapped = `0`

Neighbor inside: (1,1,3) â†’ value=3 â†’ push `(3,1,3)`

---

## ðŸ”¹ Iteration 3

Pop `(1,2,5)`
`max_h = max(1,1) = 1`
Water trapped = 0

Neighbor inside: (1,1,5) already boundary.

---

## ðŸ”¹ Iteration 4

Pop `(2,0,5)`
`max_h = max(1,2)=2`
Water trapped = 0

Neighbor inside: (1,0,4) â†’ already visited.

---

## ðŸ”¹ Iteration 5

Pop `(2,2,0)`
`max_h = max(2,2)=2`
Water trapped = 0

Neighbor: (1,1,0) already boundary.

---

## ðŸ”¹ Iteration 6

Pop `(2,2,3)`
`max_h = max(2,2)=2`
Water trapped = 0

Neighbor: (1,1,3) already pushed.

---

## ðŸ”¹ Iteration 7

Pop `(3,0,2)`
`max_h = 3`
Water = 0

---

## ðŸ”¹ Iteration 8

Pop `(3,0,4)`
`max_h = 3`
Water = 0

---

## ðŸ”¹ Iteration 9

Pop `(3,1,0)`
`max_h = 3`
Water = 0

---

## ðŸ”¹ Iteration 10

Pop `(3,2,1)`
`max_h = 3`
Water = 0

---

## ðŸ”¹ Iteration 11

Pop `(3,2,2)`
`max_h = 3`
Water = 0

---

## ðŸ”¹ Iteration 12

Pop `(3,2,4)`
`max_h = 3`
Water = 0

---

## ðŸ”¹ Iteration 13

Pop `(3,1,3)` (from earlier push)
`max_h = 3`
Water = 0

Neighbors â†’ (1,1,2) = 1 â†’ push `(1,1,2)`
(1,1,4) = 2 â†’ push `(2,1,4)`

---

## ðŸ”¹ Iteration 14

Pop `(4,0,1)`
`max_h = 4`
Water = 0

---

## ðŸ”¹ Iteration 15

Pop `(4,1,5)`
`max_h = 4`
Water = 0

---

## ðŸ”¹ Iteration 16

Pop `(1,1,2)`
`max_h = 4`
Water = `4 - 1 = 3` âœ…
Total water = 3

Neighbors â†’ (1,1,1) = 2 â†’ push `(2,1,1)`

---

## ðŸ”¹ Iteration 17

Pop `(2,1,4)`
`max_h = 4`
Water = `4 - 2 = 2` âœ…
Total water = 5

Neighbor â†’ already visited.

---

## ðŸ”¹ Iteration 18

Pop `(2,1,1)`
`max_h = 4`
Water = `4 - 2 = 2` âœ…
Total water = 7

Neighbor â†’ (1,1,2) already visited.

---

# âœ… Final Result

Total trapped water = **7**

---

# ðŸ”‘ Notes (Summary Like a Cheat-Sheet)

1. **Push all boundaries into heap.**
2. **Heap pops lowest cell â†’ ensures water always flows outwards.**
3. Keep `max_h` = tallest wall seen so far.
4. At each pop:

   ```
   water += max_h - current_height
   ```
5. Push unvisited neighbors into heap.
6. Repeat until heap empty.

