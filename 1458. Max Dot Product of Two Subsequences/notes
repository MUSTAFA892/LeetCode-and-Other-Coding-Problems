## **APPROACH 1: Dynamic Programming (DP) - EFFICIENT ✓**

### **Algorithm Explanation**

**DP State Definition:**
- `dp[i][j]` = Maximum dot product using first `i` elements of nums1 and first `j` elements of nums2

**Recurrence Relation:**
At each position `(i, j)`, we have 4 choices:
1. **Take current product only**: `nums1[i-1] * nums2[j-1]`
2. **Extend previous subsequence**: `dp[i-1][j-1] + nums1[i-1] * nums2[j-1]`
3. **Skip nums1[i-1]**: `dp[i-1][j]`
4. **Skip nums2[j-1]**: `dp[i][j-1]`

---

### **Test Case: nums1 = [2, 1, -2, 5], nums2 = [3, 0, -6]**

#### **Initial Setup**
```python
n = 4, m = 3
dp = [[float('-inf')] * 4 for _ in range(5)]

dp table (5 rows × 4 cols):
     j=0    j=1    j=2    j=3
i=0  -inf   -inf   -inf   -inf
i=1  -inf   -inf   -inf   -inf
i=2  -inf   -inf   -inf   -inf
i=3  -inf   -inf   -inf   -inf
i=4  -inf   -inf   -inf   -inf

nums1 = [2, 1, -2, 5]  (indices 0,1,2,3)
nums2 = [3, 0, -6]     (indices 0,1,2)
```

---

### **ITERATION BY ITERATION**

#### **i=1, j=1: Consider nums1[0]=2, nums2[0]=3**
```
Current product: 2 * 3 = 6

Options:
1. Take only current: 6
2. Extend previous: dp[0][0] + 6 = -inf + 6 = -inf
3. Skip nums1[0]: dp[0][1] = -inf
4. Skip nums2[0]: dp[1][0] = -inf

dp[1][1] = max(6, -inf, -inf, -inf) = 6

     j=0    j=1    j=2    j=3
i=0  -inf   -inf   -inf   -inf
i=1  -inf    6     -inf   -inf  ← Updated
i=2  -inf   -inf   -inf   -inf
i=3  -inf   -inf   -inf   -inf
i=4  -inf   -inf   -inf   -inf

Meaning: Best dot product using nums1[0..0] and nums2[0..0] is 6
Subsequence: [2] from nums1, [3] from nums2
```

---

#### **i=1, j=2: Consider nums1[0]=2, nums2[1]=0**
```
Current product: 2 * 0 = 0

Options:
1. Take only current: 0
2. Extend previous: dp[0][1] + 0 = -inf + 0 = -inf
3. Skip nums1[0]: dp[0][2] = -inf
4. Skip nums2[1]: dp[1][1] = 6

dp[1][2] = max(0, -inf, -inf, 6) = 6

     j=0    j=1    j=2    j=3
i=1  -inf    6      6     -inf  ← Keep previous best
```

---

#### **i=1, j=3: Consider nums1[0]=2, nums2[2]=-6**
```
Current product: 2 * (-6) = -12

Options:
1. Take only current: -12
2. Extend previous: dp[0][2] + (-12) = -inf + (-12) = -inf
3. Skip nums1[0]: dp[0][3] = -inf
4. Skip nums2[2]: dp[1][2] = 6

dp[1][3] = max(-12, -inf, -inf, 6) = 6

     j=0    j=1    j=2    j=3
i=1  -inf    6      6      6    ← Still best is 6
```

---

#### **i=2, j=1: Consider nums1[1]=1, nums2[0]=3**
```
Current product: 1 * 3 = 3

Options:
1. Take only current: 3
2. Extend previous: dp[1][0] + 3 = -inf + 3 = -inf
3. Skip nums1[1]: dp[1][1] = 6
4. Skip nums2[0]: dp[2][0] = -inf

dp[2][1] = max(3, -inf, 6, -inf) = 6

     j=0    j=1    j=2    j=3
i=2  -inf    6     -inf   -inf
```

---

#### **i=2, j=2: Consider nums1[1]=1, nums2[1]=0**
```
Current product: 1 * 0 = 0

Options:
1. Take only current: 0
2. Extend previous: dp[1][1] + 0 = 6 + 0 = 6
3. Skip nums1[1]: dp[1][2] = 6
4. Skip nums2[1]: dp[2][1] = 6

dp[2][2] = max(0, 6, 6, 6) = 6

     j=0    j=1    j=2    j=3
i=2  -inf    6      6     -inf
```

---

#### **i=2, j=3: Consider nums1[1]=1, nums2[2]=-6**
```
Current product: 1 * (-6) = -6

Options:
1. Take only current: -6
2. Extend previous: dp[1][2] + (-6) = 6 + (-6) = 0
3. Skip nums1[1]: dp[1][3] = 6
4. Skip nums2[2]: dp[2][2] = 6

dp[2][3] = max(-6, 0, 6, 6) = 6
```

---

#### **i=3, j=1: Consider nums1[2]=-2, nums2[0]=3**
```
Current product: -2 * 3 = -6

Options:
1. Take only current: -6
2. Extend previous: dp[2][0] + (-6) = -inf
3. Skip nums1[2]: dp[2][1] = 6
4. Skip nums2[0]: dp[3][0] = -inf

dp[3][1] = max(-6, -inf, 6, -inf) = 6
```

---

#### **i=3, j=2: Consider nums1[2]=-2, nums2[1]=0**
```
Current product: -2 * 0 = 0

Options:
1. Take only current: 0
2. Extend previous: dp[2][1] + 0 = 6 + 0 = 6
3. Skip nums1[2]: dp[2][2] = 6
4. Skip nums2[1]: dp[3][1] = 6

dp[3][2] = max(0, 6, 6, 6) = 6
```

---

#### **i=3, j=3: Consider nums1[2]=-2, nums2[2]=-6**
```
Current product: -2 * (-6) = 12

Options:
1. Take only current: 12
2. Extend previous: dp[2][2] + 12 = 6 + 12 = 18  ← BEST!
3. Skip nums1[2]: dp[2][3] = 6
4. Skip nums2[2]: dp[3][2] = 6

dp[3][3] = max(12, 18, 6, 6) = 18

     j=0    j=1    j=2    j=3
i=3  -inf    6      6      18   ← New best!

Meaning: Use [2, -2] from nums1 and [3, -6] from nums2
Dot product: 2*3 + (-2)*(-6) = 6 + 12 = 18
```

---

#### **i=4, j=1: Consider nums1[3]=5, nums2[0]=3**
```
Current product: 5 * 3 = 15

Options:
1. Take only current: 15
2. Extend previous: dp[3][0] + 15 = -inf
3. Skip nums1[3]: dp[3][1] = 6
4. Skip nums2[0]: dp[4][0] = -inf

dp[4][1] = max(15, -inf, 6, -inf) = 15
```

---

#### **i=4, j=2: Consider nums1[3]=5, nums2[1]=0**
```
Current product: 5 * 0 = 0

Options:
1. Take only current: 0
2. Extend previous: dp[3][1] + 0 = 6 + 0 = 6
3. Skip nums1[3]: dp[3][2] = 6
4. Skip nums2[1]: dp[4][1] = 15

dp[4][2] = max(0, 6, 6, 15) = 15
```

---

#### **i=4, j=3: Consider nums1[3]=5, nums2[2]=-6**
```
Current product: 5 * (-6) = -30

Options:
1. Take only current: -30
2. Extend previous: dp[3][2] + (-30) = 6 + (-30) = -24
3. Skip nums1[3]: dp[3][3] = 18
4. Skip nums2[2]: dp[4][2] = 15

dp[4][3] = max(-30, -24, 18, 15) = 18

Final answer: dp[4][3] = 18 ✓
```

---

### **Final DP Table**
```
     j=0    j=1    j=2    j=3
i=0  -inf   -inf   -inf   -inf
i=1  -inf    6      6      6
i=2  -inf    6      6      6
i=3  -inf    6      6      18
i=4  -inf    15     15     18

Answer: 18
Optimal subsequence: [2, -2] and [3, -6]
Calculation: 2*3 + (-2)*(-6) = 6 + 12 = 18
```

---

## **APPROACH 2: Brute Force (Combinations) - INEFFICIENT ✗**

### **Algorithm Explanation**

1. Generate **all possible subsequences** of nums1 and nums2
2. For each pair of subsequences **of the same length**
3. Calculate dot product
4. Track maximum

---

### **Same Test Case: nums1 = [2, 1, -2, 5], nums2 = [3, 0, -6]**

#### **Step 1: Generate All Combinations**

```python
max_len = min(4, 3) = 3

# Length 1 subsequences
arr1 from nums1: [(2,), (1,), (-2,), (5,)]
arr2 from nums2: [(3,), (0,), (-6,)]

# Length 2 subsequences
arr1 from nums1: [(2,1), (2,-2), (2,5), (1,-2), (1,5), (-2,5)]
arr2 from nums2: [(3,0), (3,-6), (0,-6)]

# Length 3 subsequences
arr1 from nums1: [(2,1,-2), (2,1,5), (2,-2,5), (1,-2,5)]
arr2 from nums2: [(3,0,-6)]
```

---

#### **Step 2: Calculate Dot Products**

**Length 1 Pairs:**
```
(2,) · (3,)   = 2*3   = 6
(2,) · (0,)   = 2*0   = 0
(2,) · (-6,)  = 2*-6  = -12
(1,) · (3,)   = 1*3   = 3
(1,) · (0,)   = 1*0   = 0
(1,) · (-6,)  = 1*-6  = -6
(-2,) · (3,)  = -2*3  = -6
(-2,) · (0,)  = -2*0  = 0
(-2,) · (-6,) = -2*-6 = 12
(5,) · (3,)   = 5*3   = 15  ← Best so far!
(5,) · (0,)   = 5*0   = 0
(5,) · (-6,)  = 5*-6  = -30

Current max = 15
```

---

**Length 2 Pairs:**
```
(2,1) · (3,0)   = 2*3 + 1*0   = 6 + 0   = 6
(2,1) · (3,-6)  = 2*3 + 1*-6  = 6 + -6  = 0
(2,1) · (0,-6)  = 2*0 + 1*-6  = 0 + -6  = -6

(2,-2) · (3,0)  = 2*3 + -2*0  = 6 + 0   = 6
(2,-2) · (3,-6) = 2*3 + -2*-6 = 6 + 12  = 18  ← NEW BEST!
(2,-2) · (0,-6) = 2*0 + -2*-6 = 0 + 12  = 12

(2,5) · (3,0)   = 2*3 + 5*0   = 6 + 0   = 6
(2,5) · (3,-6)  = 2*3 + 5*-6  = 6 + -30 = -24
(2,5) · (0,-6)  = 2*0 + 5*-6  = 0 + -30 = -30

... (more combinations)

Current max = 18
```

---

**Length 3 Pairs:**
```
(2,1,-2) · (3,0,-6) = 2*3 + 1*0 + -2*-6 = 6 + 0 + 12 = 18
(2,1,5) · (3,0,-6)  = 2*3 + 1*0 + 5*-6  = 6 + 0 + -30 = -24
(2,-2,5) · (3,0,-6) = 2*3 + -2*0 + 5*-6 = 6 + 0 + -30 = -24
(1,-2,5) · (3,0,-6) = 1*3 + -2*0 + 5*-6 = 3 + 0 + -30 = -27

Current max = 18 (no improvement)
```

---

### **Final Result: 18**

