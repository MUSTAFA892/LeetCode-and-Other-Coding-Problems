### ğŸ”‘ Key Ideas

1. **Diagonal grouping**

   * In a matrix, all elements that share the same **i + j (row index + column index)** lie on the same diagonal.
     Example: `mat[i][j]` and `mat[i+1][j-1]` both have same `i+j`.

2. **Dictionary storage**

   * `diagonals[i+j]` stores elements belonging to diagonal `i+j`.

3. **Even vs Odd diagonals**

   * For **even diagonals** (like diagonal 0, 2, 4 â€¦) â†’ reverse the collected list before adding to answer.
   * For **odd diagonals** â†’ keep them as is.
   * This gives the **zig-zag / diagonal traversal order**.

---

# ğŸ“ Working Example

Letâ€™s use:

```python
mat = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
```

---

### Step 1: Group by i+j

* `(0,0) â†’ 1` â†’ key = 0
* `(0,1) â†’ 2` , `(1,0) â†’ 4` â†’ key = 1 â†’ \[2,4]
* `(0,2) â†’ 3` , `(1,1) â†’ 5` , `(2,0) â†’ 7` â†’ key = 2 â†’ \[3,5,7]
* `(1,2) â†’ 6` , `(2,1) â†’ 8` â†’ key = 3 â†’ \[6,8]
* `(2,2) â†’ 9` â†’ key = 4 â†’ \[9]

ğŸ‘‰ Diagonals dict =

```
{
  0: [1],
  1: [2, 4],
  2: [3, 5, 7],
  3: [6, 8],
  4: [9]
}
```

---

### Step 2: Build Answer

* Key = 0 (even) â†’ reverse \[1] = \[1] â†’ ans = \[1]
* Key = 1 (odd)  â†’ keep \[2,4] â†’ ans = \[1,2,4]
* Key = 2 (even) â†’ reverse \[3,5,7] = \[7,5,3] â†’ ans = \[1,2,4,7,5,3]
* Key = 3 (odd)  â†’ keep \[6,8] â†’ ans = \[1,2,4,7,5,3,6,8]
* Key = 4 (even) â†’ reverse \[9] = \[9] â†’ ans = \[1,2,4,7,5,3,6,8,9]

---

### âœ… Final Output

```
[1, 2, 4, 7, 5, 3, 6, 8, 9]
```

This matches the **diagonal traversal order**.

---

âš¡ So the **algorithm** is:

1. Group by `i+j` â†’ collect diagonals.
2. Traverse keys in increasing order.
3. Reverse for even diagonals.
4. Append to final result.

