# **Problem Recap**

* You have an array `energy` of magicians, each giving some energy (positive or negative).
* You are **cursed**: after taking energy from magician `i`, you **must jump k steps**: go to `i+k`.
* You can **start at any magician**, and **must take the energy at every visited magician** (even negative).
* Goal: **maximize total energy** collected.

---

# **APPROACH 1 — Brute Force / Two Loops**

### **Logic**

1. Try **every starting magician** (outer loop).
2. From that magician, **keep jumping by k** until out of bounds (inner loop).
3. Sum all energies in the path.
4. Keep track of the maximum sum.

### **Pseudo Steps**

```
max_energy = []
for start in range(len(energy)):
    total = 0
    i = start
    while i < len(energy):
        total += energy[i]   # take energy (even negative)
        i += k               # jump k steps
    max_energy.append(total)

return max(max_energy)
```

### **Detailed Example**

```
energy = [5, 2, -10, -5, 1]
k = 3
```

| Start index | Path (indices visited) | Energy values | Total |
| ----------- | ---------------------- | ------------- | ----- |
| 0           | 0 → 3                  | 5, -5         | 0     |
| 1           | 1 → 4                  | 2, 1          | 3     |
| 2           | 2                      | -10           | -10   |
| 3           | 3                      | -5            | -5    |
| 4           | 4                      | 1             | 1     |

✅ Maximum energy = **3**

* This approach is **always correct**, but time complexity = **O(n²/k)** → may TLE for large arrays.

---

# **APPROACH 2 — Optimized DP (Backward Modification)**

### **Logic**

* Idea: Compute **maximum energy you can collect if starting at index i** **in-place** from the end.
* You can reuse previously computed values instead of recalculating every path.

### **Formula**

```
for i from last to first:
    if i+k < len(energy):
        energy[i] = energy[i] + energy[i+k]   # must take next energy (even if negative)
return max(energy)
```

### **Why this works**

* Start from the **end** → last magician’s max energy = energy[i] (no jump possible).
* For earlier positions → you can jump to `i+k` and **sum energies along the path**.
* Because we process from end → `energy[i+k]` is already “maximum energy from i+k onwards.”

---

### **Detailed Example**

```
energy = [5, 2, -10, -5, 1]
k = 3
```

**Backward iteration:**

1. i = 4 → no jump → energy[4] = 1
2. i = 3 → 3+3=6 (out of bounds) → energy[3] = -5
3. i = 2 → 2+3=5 (out of bounds) → energy[2] = -10
4. i = 1 → 1+3=4 → energy[1] += energy[4] → 2 + 1 = 3
5. i = 0 → 0+3=3 → energy[0] += energy[3] → 5 + (-5) = 0

Final energy array after DP: `[0, 3, -10, -5, 1]`
✅ Maximum energy = **3**

---

# **Key Differences Between Two Approaches**

| Feature                | Approach 1 (Two loops)        | Approach 2 (DP backward)                               |
| ---------------------- | ----------------------------- | ------------------------------------------------------ |
| Method                 | Compute every path separately | Compute max energy from the end using previous results |
| Time Complexity        | O(n²/k)                       | O(n)                                                   |
| Space Complexity       | O(n) (for max_energy array)   | O(1) (in-place)                                        |
| Handles negative jumps | Yes, explicitly sums them     | Yes, automatically (always adds next energy)           |
| Good for large input   | ❌ may TLE                     | ✅ Efficient                                            |
| Conceptually simpler   | Easy to understand            | Slightly tricky but elegant                            |
