
### âœ… **Problem**

Given an array `nums` where:

* Half of the integers are **even**
* Half are **odd**

**Goal**: Rearrange the array so that:

* Elements at **even indices** are even
* Elements at **odd indices** are odd

---

### ğŸ’¡ **Core Idea**

Use two pointers:

* `even_idx` â†’ starts at 0 (goes over even indices)
* `odd_idx` â†’ starts at 1 (goes over odd indices)

Move each pointer by 2 steps at a time.

* If both elements are in their correct places, just increment pointers.
* If:

  * `nums[even_idx]` is **odd** AND
  * `nums[odd_idx]` is **even**
    â†’ **Swap** them.

---

### ğŸ› ï¸ **Step-by-Step Logic**

1. Start both pointers (`even_idx = 0`, `odd_idx = 1`).
2. While both pointers are within bounds:

   * If `nums[even_idx]` is even â†’ correct â†’ move ahead.
   * If `nums[odd_idx]` is odd â†’ correct â†’ move ahead.
   * If both are wrong (odd at even index, even at odd index) â†’ **swap** and move both.

---

### ğŸ” **Example Walkthrough**

Input:

```python
nums = [4, 1, 2, 3]
```

Initial:

* `even_idx = 0` â†’ `nums[0] = 4` â†’ even âœ…
* `odd_idx = 1` â†’ `nums[1] = 1` â†’ odd âœ…

Move both: `even_idx = 2`, `odd_idx = 3`

* `nums[2] = 2` â†’ even âœ…
* `nums[3] = 3` â†’ odd âœ…

âœ… Already sorted â†’ Output: `[4, 1, 2, 3]`

---

### ğŸ“ˆ **Time & Space Complexity**

* **Time:** O(n) â€” one pass through the array.
* **Space:** O(1) â€” in-place sorting, no extra memory used.
