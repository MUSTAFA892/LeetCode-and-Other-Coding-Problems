# **Is Array Trionic (Mountain Array)**

## **Problem**
Check if array is "trionic" (mountain-shaped):
- Strictly increases to a peak
- Then strictly decreases
- No plateaus (consecutive equal elements)
- At least 3 elements

---

## **Test Case: nums = [1, 3, 5, 4, 2]**

---

## **STEP 1: Build Direction Map**

```python
nums = [1, 3, 5, 4, 2]
change = inf
map_ = []

Process adjacent pairs to detect increasing (1) or decreasing (0)
```

---

### **i = 0: Compare nums[0]=1 with nums[1]=3**

```python
Check: nums[0] == nums[1]?
       1 == 3? NO

Check: nums[0] < nums[1]?
       1 < 3? YES ✓
       
change = 1 (increasing)

map_.append(1)
map_ = [1]

Visual:
[1, 3, 5, 4, 2]
 ↑  ↑
 1 < 3 → increasing (1)
```

---

### **i = 1: Compare nums[1]=3 with nums[2]=5**

```python
Check: 3 == 5? NO

Check: 3 < 5? YES ✓

change = 1 (increasing)

map_.append(1)
map_ = [1, 1]

Visual:
[1, 3, 5, 4, 2]
    ↑  ↑
    3 < 5 → increasing (1)
```

---

### **i = 2: Compare nums[2]=5 with nums[3]=4**

```python
Check: 5 == 4? NO

Check: 5 < 4? NO

else:
  change = 0 (decreasing)

map_.append(0)
map_ = [1, 1, 0]

Visual:
[1, 3, 5, 4, 2]
       ↑  ↑
       5 > 4 → decreasing (0)
```

---

### **i = 3: Compare nums[3]=4 with nums[4]=2**

```python
Check: 4 == 2? NO

Check: 4 < 2? NO

change = 0 (decreasing)

map_.append(0)
map_ = [1, 1, 0, 0]

Visual:
[1, 3, 5, 4, 2]
          ↑  ↑
          4 > 2 → decreasing (0)
```

---

### **Loop Complete - Direction Map Built**

```python
map_ = [1, 1, 0, 0]

Interpretation:
Index:  0   1   2   3   4
nums:  [1,  3,  5,  4,  2]
        └─↑─┴─↑─┴─↓─┴─↓─┘
         1   1   0   0
        ↑↑  peak  ↓↓
```

---

## **STEP 2: Initial Validation Checks**

```python
map_ = [1, 1, 0, 0]
len(map_) = 4

Check 1: len(map_) < 3?
         4 < 3? NO ✓

Check 2: map_[0] == 0?
         map_[0] = 1
         1 == 0? NO ✓
         (Must start increasing)

Check 3: map_[-1] == 0?
         map_[-1] = map_[3] = 0
         0 == 0? YES ✗
         
Wait, this check seems wrong...
Actually: map_[-1] == 0 checks if last is decreasing
For mountain, we WANT it to end decreasing!

The condition "map_[-1] == 0" returns False means:
"If last is decreasing, return False" ← This is WRONG!

Let me re-read the logic...
```

---

### **Wait - Logic Issue!**

```python
if len(map_) < 3 or map_[0] == 0 or map_[-1] == 0 or 0 not in map_:
    return False
```

This condition returns `False` if **ANY** of these are true:
1. `len(map_) < 3` - too short
2. `map_[0] == 0` - starts decreasing (bad)
3. `map_[-1] == 0` - ends decreasing (WAIT, this should be GOOD!)
4. `0 not in map_` - no decrease at all (bad)

**BUG:** `map_[-1] == 0` should be `map_[-1] == 1` (shouldn't end increasing)

Let me continue with the actual code logic:

---

### **Continuing with Given Code:**

```python
Check: len(map_) < 3 or map_[0] == 0 or map_[-1] == 0 or 0 not in map_?

len(map_) < 3? 4 < 3? NO
map_[0] == 0? 1 == 0? NO
map_[-1] == 0? 0 == 0? YES ✓

Since one condition is True:
return False

BUT WAIT - for [1,3,5,4,2], this IS a valid mountain!
The code has a bug!
```

---

## **Let me trace with nums = [1, 3, 5, 3, 1] (also valid mountain)**

### **Build map_:**

```python
i=0: 1<3 → map_=[1]
i=1: 3<5 → map_=[1,1]
i=2: 5>3 → map_=[1,1,0]
i=3: 3>1 → map_=[1,1,0,0]

map_ = [1, 1, 0, 0]
```

Same result, same bug!

---

## **Let me trace with corrected understanding**

Actually, I think the code might be checking for something else. Let me re-trace assuming the logic is meant to work:

For a valid mountain:
- Should start with 1 (increasing)
- Should end with 0 (decreasing)
- Should have both 1s and 0s

So the check `map_[-1] == 0` returning False is **wrong for mountains**.

Let me assume there's a typo and it should be:
```python
if len(map_) < 3 or map_[0] == 0 or map_[-1] == 1 or 0 not in map_:
```

---

## **Corrected Trace: nums = [1, 3, 5, 4, 2]**

### **Step 2: Initial Validation (CORRECTED)**

```python
map_ = [1, 1, 0, 0]

Check: len(map_) < 3 or map_[0] == 0 or map_[-1] == 1 or 0 not in map_?

len(map_) < 3? 4 < 3? NO
map_[0] == 0? 1 == 0? NO ✓ (starts increasing, good)
map_[-1] == 1? 0 == 1? NO ✓ (ends decreasing, good)
0 not in map_? 0 in [1,1,0,0]? YES, so "0 not in map_" = NO ✓

All checks pass, continue...
```

---

## **STEP 3: Count Direction Changes**

```python
map_ = [1, 1, 0, 0]
changes = 0

Look for transitions in direction
```

### **i = 1: Compare map_[1] with map_[0]**

```python
map_[i] != map_[i-1]?
map_[1] != map_[0]?
1 != 1? NO

changes = 0

State: [1, 1, 0, 0]
           ↑  ↑
        Same direction, no change
```

---

### **i = 2: Compare map_[2] with map_[1]**

```python
map_[i] != map_[i-1]?
map_[2] != map_[1]?
0 != 1? YES ✓

changes += 1
changes = 1

State: [1, 1, 0, 0]
              ↑  ↑
          Direction changed! (1→0, peak)
```

---

### **i = 3: Compare map_[3] with map_[2]**

```python
map_[i] != map_[i-1]?
map_[3] != map_[2]?
0 != 0? NO

changes = 1

State: [1, 1, 0, 0]
                 ↑  ↑
          Same direction, no change
```

---

### **Loop Complete**

```python
changes = 1

Visual:
map_ = [1, 1, 0, 0]
        ↑↑ → ↓↓
        
Only 1 transition: from increasing to decreasing
```

---

## **STEP 4: Validate Change Count**

```python
Check: changes != 2?
       1 != 2? YES

return False

WAIT - This is wrong!
For a valid mountain, we should have exactly 1 transition (increase → decrease)
But the code checks for 2 transitions!
```

---

## **Understanding the Bug**

The code expects **2 transitions**, which would mean:
- Transition 1: Something → increasing
- Transition 2: Increasing → decreasing

But for a mountain starting from the beginning, there's only **1 transition**!

---

## **Let me test with nums = [2, 1, 3, 5, 4] (invalid - decreases then increases)**

### **Build map_:**

```python
i=0: 2>1 → map_=[0]
i=1: 1<3 → map_=[0,1]
i=2: 3<5 → map_=[0,1,1]
i=3: 5>4 → map_=[0,1,1,0]

map_ = [0, 1, 1, 0]
```

### **Validation:**

```python
map_[0] == 0? YES
return False ✓ (correctly rejects)
```

---

## **Corrected Algorithm Understanding**

I think the code has bugs. Here's what a **correct** mountain checker should do:

```python
def isTrionic(nums):
    if len(nums) < 3:
        return False
    
    # Build direction map
    map_ = []
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            return False  # No plateaus
        map_.append(1 if nums[i] < nums[i+1] else 0)
    
    # Must start increasing, end decreasing, have both
    if map_[0] == 0 or map_[-1] == 1 or 1 not in map_ or 0 not in map_:
        return False
    
    # Count transitions
    changes = 0
    for i in range(1, len(map_)):
        if map_[i] != map_[i-1]:
            changes += 1
    
    # Exactly 1 transition for mountain
    return changes == 1
```

---

## **Summary of Code Issues**

| Line | Issue | Should Be |
|------|-------|-----------|
| `if True:` | Useless condition | Remove |
| `map_[-1] == 0` | Wrong check | `map_[-1] == 1` |
| `changes != 2` | Wrong count | `changes != 1` |

---

## **Trace with Corrected Logic: nums = [1,3,5,4,2]**

```python
map_ = [1, 1, 0, 0]

Checks:
✓ len >= 3
✓ starts with 1
✓ ends with 0  
✓ has both 1 and 0

Transitions: 1 (at index 2: 1→0)

changes == 1? YES ✓

return True (valid mountain!)
```

---

## **Final Answer**

The given code has **bugs** but the concept is:
1. Build direction map (1=increasing, 0=decreasing)
2. Check starts increasing, ends decreasing
3. Count direction changes (should be exactly 1 for mountain)

For `[1, 3, 5, 4, 2]` with **corrected code**:
- map_ = [1, 1, 0, 0]
- 1 transition
- **Valid mountain!** ✓