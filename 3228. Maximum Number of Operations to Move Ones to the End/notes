# ‚úÖ **Understanding the Problem (Quick Recap)**

You are given a binary string `s`.

You can perform an operation whenever you find:

```
s[i] == '1' and s[i+1] == '0'
```

Then you move that `'1'` as far right as possible.

The question:
üëâ **How many operations can we perform in total?**

A key observation from the editorial is that:

> Every time `'1'` moves right, it may create *new* `"10"` pairs earlier in the string.
> So we cannot simulate; we must count *potential crossings*.

---

# ‚úÖ **Your Final Code**

```python
class Solution:
    def maxOperations(self, s: str) -> int:
        ones_count = 0
        total_ops = 0

        for i in range(len(s)):
            if s[i] == '1':
                ones_count += 1

            elif s[i] == '0' and i > 0 and s[i-1] == '1':
                total_ops += ones_count
        
        return total_ops
```

---

# ‚úÖ **Explanation of the Code (Line-by-Line Note)**

### **1. Initialize counters**

```python
ones_count = 0
total_ops = 0
```

* `ones_count` = how many `'1'`s we have seen **so far**
* `total_ops` = total number of operations we can perform

---

### **2. Loop through every character**

```python
for i in range(len(s)):
```

We scan **left to right**, because operations affect the left side.

---

### **3. Case 1: Current character is `'1'`**

```python
if s[i] == '1':
    ones_count += 1
```

Why?

Whenever we see a `'1'`, that `'1'` has the potential to move right.
It increases the number of ones that future zeros can interact with.

---

### **4. Case 2: Current character is `'0'` AND previous char is `'1'`**

```python
elif s[i] == '0' and i > 0 and s[i-1] == '1':
    total_ops += ones_count
```

This means we found a `"10"` at position `(i-1, i)`.

But **why add `ones_count` and not just `1`?**

Because:

* Every `'1'` **before** this zero can eventually ‚Äúbubble‚Äù across this zero.
* Each crossing = one operation.

So if there are `ones_count` ones behind this zero,
they can produce `ones_count` operations over this particular `"10"` pair.

---

### **5. Return the answer**

```python
return total_ops
```

---

# ‚≠ê **Intuition in One Sentence:**

Every `'1'` can cross every `'0'` that appears **to its right**.
Your logic counts all such crossings.

---

# üî• **WORKING EXAMPLE (Step-by-Step)**

Let's use the example:

```
s = "1001101"
```

We will track:

* `ones_count`
* `total_ops`

---

### **Start**

```
ones_count = 0
total_ops = 0
```

---

### **i = 0 ‚Üí '1'**

```
ones_count = 1
```

---

### **i = 1 ‚Üí '0'**

Previous = `'1'`, so we have a `"10"` pair.

```
total_ops += ones_count
total_ops = 1
```

Meaning:
The `'1'` at index 0 can cross this zero ‚Üí 1 operation.

---

### **i = 2 ‚Üí '0'**

Previous char is `'0'`, so ignore.

---

### **i = 3 ‚Üí '1'**

```
ones_count = 2
```

There are now two `'1'`s that may cross future zeros.

---

### **i = 4 ‚Üí '1'**

```
ones_count = 3
```

---

### **i = 5 ‚Üí '0'**

Previous char is `'1'`, so `"10"` exists.

So:

```
total_ops += ones_count
total_ops += 3
total_ops = 1 + 3 = 4
```

Interpretation:
All three `'1'`s at indexes `[0, 3, 4]` can cross this zero ‚Üí 3 operations.

---

### **i = 6 ‚Üí '1'**

```
ones_count = 4
```

---

# ‚≠ê FINAL VALUES

```
total_ops = 4
```
