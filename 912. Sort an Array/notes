## ðŸ§© **Approach 1: Merge Sort (Custom Implementation)**

### ðŸ§  Explanation (Step-by-Step Algorithm)

1. **Base case**:
   If the list has one or zero elements â†’ itâ€™s already sorted â†’ return it.

2. **Divide**:
   Split the array into two halves:

   ```python
   mid = len(nums) // 2
   left = merge_sort(nums[:mid])
   right = merge_sort(nums[mid:])
   ```

3. **Conquer (Recursion)**:
   Recursively call `merge_sort` on the left and right halves until you reach single elements.

4. **Merge**:
   Use the `merge()` function to combine two sorted halves into a single sorted list.

5. **Return**:
   Finally, return the sorted list.

### ðŸ§® Example walkthrough

Input:

```python
nums = [5, 2, 3, 1]
```

**Step 1:** Split into `[5, 2]` and `[3, 1]`
**Step 2:** Sort each â†’ `[2, 5]` and `[1, 3]`
**Step 3:** Merge â†’ `[1, 2, 3, 5]`

âœ… **Output:**

```
[1, 2, 3, 5]
```

### â±ï¸ Time & Space Complexity

| Operation | Complexity                     |
| --------- | ------------------------------ |
| Time      | O(n log n)                     |
| Space     | O(n) (extra space for merging) |

---

## âš¡ **Approach 2: Using Pythonâ€™s Built-in `.sort()`**

### âœ… Code:

```python
from typing import List

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
```

### ðŸ§  Explanation:

* The `.sort()` method in Python uses **Timsort**, a hybrid sorting algorithm that combines **Merge Sort** and **Insertion Sort**.
* Itâ€™s highly optimized for real-world data (partially sorted arrays, small subarrays, etc.).

### ðŸ§® Example:

Input:

```python
nums = [5, 2, 3, 1]
```

Python internally handles all the splitting, merging, and comparison optimizations.

âœ… **Output:**

```
[1, 2, 3, 5]
```
