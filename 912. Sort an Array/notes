## 🧩 **Approach 1: Merge Sort (Custom Implementation)**

### 🧠 Explanation (Step-by-Step Algorithm)

1. **Base case**:
   If the list has one or zero elements → it’s already sorted → return it.

2. **Divide**:
   Split the array into two halves:

   ```python
   mid = len(nums) // 2
   left = merge_sort(nums[:mid])
   right = merge_sort(nums[mid:])
   ```

3. **Conquer (Recursion)**:
   Recursively call `merge_sort` on the left and right halves until you reach single elements.

4. **Merge**:
   Use the `merge()` function to combine two sorted halves into a single sorted list.

5. **Return**:
   Finally, return the sorted list.

### 🧮 Example walkthrough

Input:

```python
nums = [5, 2, 3, 1]
```

**Step 1:** Split into `[5, 2]` and `[3, 1]`
**Step 2:** Sort each → `[2, 5]` and `[1, 3]`
**Step 3:** Merge → `[1, 2, 3, 5]`

✅ **Output:**

```
[1, 2, 3, 5]
```

### ⏱️ Time & Space Complexity

| Operation | Complexity                     |
| --------- | ------------------------------ |
| Time      | O(n log n)                     |
| Space     | O(n) (extra space for merging) |

---

## ⚡ **Approach 2: Using Python’s Built-in `.sort()`**

### ✅ Code:

```python
from typing import List

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
```

### 🧠 Explanation:

* The `.sort()` method in Python uses **Timsort**, a hybrid sorting algorithm that combines **Merge Sort** and **Insertion Sort**.
* It’s highly optimized for real-world data (partially sorted arrays, small subarrays, etc.).

### 🧮 Example:

Input:

```python
nums = [5, 2, 3, 1]
```

Python internally handles all the splitting, merging, and comparison optimizations.

✅ **Output:**

```
[1, 2, 3, 5]
```
