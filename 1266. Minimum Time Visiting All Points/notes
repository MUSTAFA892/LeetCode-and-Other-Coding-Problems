# **Minimum Time to Visit All Points**

## **Problem**
Calculate minimum time to visit all points in order. You can move:
- Horizontally, vertically, or diagonally
- Each move (including diagonal) takes 1 second

**Key Insight:** Diagonal moves cover both x and y simultaneously, so time = max(|Δx|, |Δy|)

---

## **Test Case: points = [[1,1], [3,4], [-1,0]]**

---

## **APPROACH 1: Optimized (Math Formula) ✓**

### **Algorithm**
Time to move from point A to point B = `max(|x₂-x₁|, |y₂-y₁|)`

---

### **Execution**

```python
points = [[1,1], [3,4], [-1,0]]
count = 0
```

---

#### **i = 1: Move from [1,1] to [3,4]**

```python
From: points[0] = [1, 1]
To:   points[1] = [3, 4]

Calculate differences:
Δx = |3 - 1| = |2| = 2
Δy = |4 - 1| = |3| = 3

Time = max(2, 3) = 3

count = 0 + 3 = 3

Visual path:
[1,1] → [2,2] → [3,3] → [3,4]
  ↘      ↘      ↓
  diagonal diagonal vertical
  
Step 1: (1,1) → (2,2)  diagonal move
Step 2: (2,2) → (3,3)  diagonal move
Step 3: (3,3) → (3,4)  vertical move
Total: 3 steps
```

---

#### **i = 2: Move from [3,4] to [-1,0]**

```python
From: points[1] = [3, 4]
To:   points[2] = [-1, 0]

Calculate differences:
Δx = |-1 - 3| = |-4| = 4
Δy = |0 - 4| = |-4| = 4

Time = max(4, 4) = 4

count = 3 + 4 = 7

Visual path:
[3,4] → [2,3] → [1,2] → [0,1] → [-1,0]
  ↙      ↙      ↙      ↙
  diagonal diagonal diagonal diagonal
  
Step 1: (3,4) → (2,3)  diagonal move
Step 2: (2,3) → (1,2)  diagonal move
Step 3: (1,2) → (0,1)  diagonal move
Step 4: (0,1) → (-1,0) diagonal move
Total: 4 steps
```

---

### **Final Result**
```
Total time = 3 + 4 = 7
```

---

## **Step-by-Step Visual**

```
Grid visualization:

Point [1,1] to [3,4]:
    0   1   2   3   4
  +---+---+---+---+---+
4 |   |   |   | E |   |  End
  +---+---+---+---+---+
3 |   |   | ↗ |   |   |
  +---+---+---+---+---+
2 |   | ↗ |   |   |   |
  +---+---+---+---+---+
1 |   | S |   |   |   |  Start
  +---+---+---+---+---+
0 |   |   |   |   |   |
  +---+---+---+---+---+

Path: diagonal 2 times, then vertical 1 time = 3 steps

Point [3,4] to [-1,0]:
   -1   0   1   2   3
  +---+---+---+---+---+
4 |   |   |   |   | S |  Start
  +---+---+---+---+---+
3 |   |   |   | ↙ |   |
  +---+---+---+---+---+
2 |   |   | ↙ |   |   |
  +---+---+---+---+---+
1 |   | ↙ |   |   |   |
  +---+---+---+---+---+
0 | E |   |   |   |   |  End
  +---+---+---+---+---+

Path: diagonal 4 times = 4 steps
```

---

## **APPROACH 2: Simulation (Brute Force) - Commented Code**

### **How It Works**
Simulate actual movement step-by-step.

---

### **Execution for Same Test Case**

#### **i = 1: Move from [1,1] to [3,4]**

```python
val = [1, 1]  (copy of points[0])
target = [3, 4]
count = 0

While val != [3, 4]:
```

**Iteration 1:**
```
val = [1, 1], target = [3, 4]
count += 1 → count = 1

Check x: 1 < 3 → val[0] += 1 → val[0] = 2
Check y: 1 < 4 → val[1] += 1 → val[1] = 2

val = [2, 2]
```

**Iteration 2:**
```
val = [2, 2], target = [3, 4]
count += 1 → count = 2

Check x: 2 < 3 → val[0] += 1 → val[0] = 3
Check y: 2 < 4 → val[1] += 1 → val[1] = 3

val = [3, 3]
```

**Iteration 3:**
```
val = [3, 3], target = [3, 4]
count += 1 → count = 3

Check x: 3 == 3 → no change
Check y: 3 < 4 → val[1] += 1 → val[1] = 4

val = [3, 4]  ← Reached target!
```

**Total for this segment: 3 steps**

---

#### **i = 2: Move from [3,4] to [-1,0]**

```python
val = [3, 4]  (copy of points[1])
target = [-1, 0]
count = 3 (from previous)

While val != [-1, 0]:
```

**Iteration 1:**
```
count = 4
Check x: 3 > -1 → val[0] -= 1 → val[0] = 2
Check y: 4 > 0  → val[1] -= 1 → val[1] = 3
val = [2, 3]
```

**Iteration 2:**
```
count = 5
val[0] -= 1 → val[0] = 1
val[1] -= 1 → val[1] = 2
val = [1, 2]
```

**Iteration 3:**
```
count = 6
val[0] -= 1 → val[0] = 0
val[1] -= 1 → val[1] = 1
val = [0, 1]
```

**Iteration 4:**
```
count = 7
val[0] -= 1 → val[0] = -1
val[1] -= 1 → val[1] = 0
val = [-1, 0]  ← Reached target!
```

**Total: 7 steps**
