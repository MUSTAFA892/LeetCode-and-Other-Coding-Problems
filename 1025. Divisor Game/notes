# ğŸ“ Problem Idea (Divisor Game)

Two players play a game:

* Player 1 â†’ **Alice**
* Player 2 â†’ **Bob**
* They start with a number **n**
* On each turn, the player chooses a number **x** such that:

  * `1 â‰¤ x < n`
  * `x` divides `n` perfectly (`n % x == 0`)
* Then the player **replaces n with n âˆ’ x**
* The player who **cannot make a move loses**

The function returns:

* `True` â†’ Alice wins
* `False` â†’ Bob wins

---

# âœ… Key Insight

Your code:

```python
class Solution:
    def divisorGame(self, n: int) -> bool:
        if n % 2 == 0:
            return True
        else:
            return False
```

This means:

### âœ” If `n` is even â†’ Alice always wins

### âœ” If `n` is odd â†’ Alice always loses

And this is **mathematically correct**.

---

# ğŸ” Why is this true?

* If `n` is **even**, Alice can always choose an **odd divisor**, making the number odd for Bob.
* If `n` is **odd**, every divisor is odd, so after subtraction the result becomes **even**, giving Alice an even number back but only after Bobâ€™s move â€” meaning Alice eventually gets stuck.

So the pattern becomes:

| n | Winner |
| - | ------ |
| 1 | Bob    |
| 2 | Alice  |
| 3 | Bob    |
| 4 | Alice  |
| 5 | Bob    |
| 6 | Alice  |

So:

```
Even â†’ Alice wins
Odd  â†’ Alice loses
```

---

# ğŸ§ª Working Example Flow

### Example: `n = 4`

We check:

```
4 % 2 == 0  â†’ True
```

So the function returns:

```
True  â†’ Alice wins
```

But letâ€™s see the game flow:

---

## ğŸ® Game Play

### Start:

```
n = 4
Alice's turn
```

Alice must choose a divisor `x` of 4:

Possible x:

```
1, 2
```

Suppose Alice chooses:

```
x = 1
```

Then:

```
n = 4 âˆ’ 1 = 3
```

---

### Bobâ€™s turn:

```
n = 3
```

Divisors of 3:

```
1
```

Bob must choose:

```
x = 1
```

So:

```
n = 3 âˆ’ 1 = 2
```

---

### Aliceâ€™s turn:

```
n = 2
```

Divisors of 2:

```
1
```

Alice chooses:

```
x = 1
```

So:

```
n = 2 âˆ’ 1 = 1
```

---

### Bobâ€™s turn:

```
n = 1
```

Bob has **no valid moves**

So:

```
Bob loses
Alice wins
```
