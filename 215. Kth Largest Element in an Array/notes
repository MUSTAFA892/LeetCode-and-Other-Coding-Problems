### ğŸ’¡ **Core Idea**

Use a **min-heap** of size `k` to track the top `k` largest elements.

* Python's `heapq` is a **min-heap**: the smallest element is always at the top (`heap[0]`).
* After processing all elements, the **smallest in the heap** is the **k-th largest** overall.

---

### ğŸ› ï¸ **Step-by-Step Explanation**

1. **Initialize a min-heap**.
2. **Push the first `k` elements** into the heap.
3. **For the rest of the elements** in the array:

   * If the current number is **greater than the heap's top**, replace the top with the current number.
4. After all elements are processed, the **heap's top (heap\[0])** is the answer.

---

### ğŸ” **Example Walkthrough**

Given:

```python
nums = [3, 2, 1, 5, 6, 4]
k = 2
```

#### Step 1: First 2 elements go into the heap

* Heap becomes: `[2, 3]`

#### Step 2: Process the rest

* 1 â†’ smaller than 2 â†’ skip
* 5 â†’ bigger than 2 â†’ replace 2 â†’ heap: `[3, 5]`
* 6 â†’ bigger than 3 â†’ replace 3 â†’ heap: `[5, 6]`
* 4 â†’ smaller than 5 â†’ skip

#### Final heap: `[5, 6]`

â¡ï¸ **Top of heap (5)** is the **2nd largest**.

---

### ğŸ“ˆ **Time & Space Complexity**

* **Time:** `O(n log k)`
* **Space:** `O(k)` â€” only `k` elements in the heap.

